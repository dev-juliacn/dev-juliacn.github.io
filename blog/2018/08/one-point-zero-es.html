<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Julia 1.0</title>
<meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al." />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
<link rel="stylesheet" href="/v2/css/bootstrap.min.css" />
<link rel="stylesheet" href="/v2/css/app.css" />
<link rel="stylesheet" href="/v2/css/fonts.css" />
<link rel="stylesheet" href="/v2/css/highlight/github.css" />
</head>

<body>

   

<!-- main menu -->
<div class="container py-3 py-lg-0">
  <nav class="navbar navbar-expand-lg navbar-light bg-light" id="main-menu">

    <a class="navbar-brand" href="/" id="logo">
      <img src="/v2/img/logo.png" height="55" width="118" />
    </a>

    <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <!-- li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/">Home</a>
        </li -->
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/downloads">下载</a>
        </li>
        <li class="nav-item flex-md-fill text-md-center">
          <a class="nav-link" href="http://docs.juliacn.com/">文档</a>
        </li>
        <li class="nav-item  active  flex-md-fill text-md-center">
          <a class="nav-link" href="/blog/">Blog</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="/meetups">活动</a>
        </li>
      </ul>
    </div>

  </nav>
</div>
<!-- end main menu -->


   <br /><br />

  <div class="container">
    <br /><br />

<div class="container">

  <div class="row">
    <div class="col-12 col-lg-8 offset-lg-2">
      <h1></h1>

<div id="blogpost">
  <h1>Julia 1.0</h1>

  <p class="metadata">
    <span class="timestamp">08 Aug 2018</span>
    
  </p>

  <p>La anticipada liberación de la versión 1.0 de <a href="https://julialang.org">Julia</a> es la culminación
de casi una década de trabajo por programadores ambiciosos. JuliaCon2018
celebró la ocasión con un evento donde la comunidad oficialmente <a href="https://www.youtube.com/watch?v=1jN5wKvN-Uk#t=3850">lanzó la versión
1.0.0 juntos.</a>.</p>

<p>El primer comunicado de Julia <a href="https://julialang.org/blog/2012/02/why-we-created-julia">público</a> con
número de exigencias sobre el lenguaje:</p>

<blockquote>
  <p>Queremos un lenguaje que sea de licencia abierta, con licencia libera. Queremos la velocidad de C
con el dinamismo de Ruby. Queremos un lenguaje que sea homoicónico, con macros verdaderos tipo Lisp,
pero con notación matemática, obvia y familiar como Matlab. Queremos algo usable
para programación general como Python, tan fácil para estadísticas como R, tan natural para procesamiento
de cadenas como Perl, tan potente para álgebra lineal como Matlab, tan bueno uniendo programas juntos como
un shell. Algo que sea sumamente sencillo para aprender, pero que mantenga a los hackers más serios
felices. Queremos que sea interactivo y que sea compilado.</p>
</blockquote>

<p>Una comunidad vibrante y fructífera ha crecido alrededor de este lenguaje, con gente de 
todo el mundo iterativamente refinando y reformulado Julia para cumplir su meta. Más de 700
personas han contribuido a Julia en sí y aún más gente han hecho miles de paquetes de código abierto
asombrosos. En resumen, hemos construido un lenguaje que es:</p>

<ul>
  <li><strong>Rápido</strong>: Julia fue diseñado desde el principio para tener alto rendimiento. Los programas de Julia
se compilan a código nativo eficiente para muchas plataformas por medio de LLVM.</li>
  <li><strong>General</strong>: Usa despacho múltiple como paradigma, facilitando expresar muchos patrones de 
la programación orientada a objetos ó programación funcional. La biblioteca estándar provee
I/O asíncrono, control de procesos, logging, perfiles, un administrador de paquetes, y más.</li>
  <li><strong>Técnico</strong>: Sobresale en cómputo numérico con una sintáxis excelente para las matemáticas,
amplio soporte para muchos tipos de datos, y pararelismo incluido por default. Su despacho múltiple
es un embone natural para definir tipos de datos numéricos y de arreglos.</li>
  <li><strong>Opcionalmente tipado</strong>: Julia tiene un lenguaje rico para describir tipos de datos, y la declaración
de tipos puede ser usada para clarificar y solidificar programas.</li>
  <li><strong>Componible</strong>: Los paquetes de Julia se pueden simultáneamente sin dificultad. Matrices de cantidades
unitarias, ó datos de columnas tabuladas de divisas y colores – todo funciona – y a buena velocidad.</li>
</ul>

<p>Intenta Julia al bajar la <a href="https://julialang.org/downloads/">versión 1.0 ahora</a>. Si estás actualizando
código de Julia 0.6 o versiones anteriroes, te recomendamos que primero uses 0.7 como transición. Una vez
que tu código esté libre de warnings, puedes cambiarlo a 1.0 pérdida de funcionalidad. Los paquetes registrados 
están aprovechando esta etapa de transición y liberando sus actualizaciones compatibles con 1.0.</p>

<p>La ventaja más importante de Julia 1.0 es, por supuesto, es un compromiso de estabilidad de API:
código que escribes para Julia 1.0 seguirá funcionando en 1.1, 1.2, etc. El lenguaje está “completo”.
Los desarrolladores principales y la comunidad pueden enfocarse en paquetería, herramientas, y nuevas
funcionalidades que construir sobre una base sólida.</p>

<p>Pero Julia 1.0 no es sólo sobre estabilidad, también introduce nuevas y poderosas inovaciones del lenguaje.
Algunas de estas novedades desde 0.6 incluyen:</p>

<ul>
  <li>
    <p>Un nuevo e incluido <a href="https://docs.julialang.org/en/latest/stdlib/Pkg/">administrador de paquetes</a>
trae enormes mejoras de rendimiento y facilita más que nunca la instalación de paquetes y sus 
dependencias. También soporta ambientos particulares a cada proyecto y registros de estado exactos para
una aplicación para poderla compartir con los demás - y tu futuro yo. Finalmente, el rediseño también introduce
spoporte integrado para paquetes privados y repositorios. Tú puedes instalar y administrar paqueterías
privadas con las mismas herramientas que el ecosistema de paquetería abierta. La <a href="https://www.youtube.com/watch?v=GBi__3nF-rM">presentación de
JuliaCon</a> resume el nuevo diseño y capacidades.</p>
  </li>
  <li>
    <p>Julia tiene una nuueva <a href="https://julialang.org/blog/2018/06/missing">representación canónica para valores faltantes</a>.
Poder representar y trabajar con datos faltantes es fundamental para estadísticas y ciencias de datos. En estilo Juliano,
la nueva solución es general, componible, y rápida. Cualquier colección general puede eficientemente
soportar valores faltantes simplemente al permitir que elementos incluyan el valor predefinido <code class="highlighter-rouge">missing</code>. 
El rendimiento de dadas colecciones “tipadas como uniones” hubieran sido demasiado lentas en versiones anteriores
de Julia, pero mejoras de compiladores permiten ahora que Julia sea comparables a la velocidad de valores faltantes 
en C ó C++ en otros sistemas, mientras que sigue siendo más general y flexible.</p>
  </li>
  <li>
    <p>El tipo <code class="highlighter-rouge">String</code> ahora puede contener datos arbitrarios. Tu programa no fallará después de horas ó días porque
un sólo byte de Unicode era inválido. Todos los datos de cadenas son preservados mientras que se indica cuáles caracteres
son válidos o inválidos, permitiendo que sus aplicaciones sean conveniente y seguramente usados en datos reales con todas sus
inevitables complicaciones.</p>
  </li>
  <li>
    <p>“Broadcasting” ya es una ventaja clave con sintáxis conveniente – y ahora es más poderosa que nunca. En 
Julia 1.0 es fácil <a href="https://julialang.org/blog/2018/05/extensible-broadcast-fusion">extender broadcasting a tipos de usuario</a> e implementarlo
en cálculos optimizados para GPUs y hardware vectorizado, pavimentando el camino para aún más mejoras en el futuro.</p>
  </li>
  <li>
    <p>Las tuplas con nombre son rasgo nuevo que permiete representar y accesar datos por nombre y de manera eficiente. Puedes, por ejemplo,
representar una hilera de datos como <code class="highlighter-rouge">row =
(name="Julia", version=v"1.0.0", releases=8)</code> y accesar su columna <code class="highlighter-rouge">version</code> como 
<code class="highlighter-rouge">row.version</code> con la misma velocidad que el inconveniente <code class="highlighter-rouge">row[2]</code>.</p>
  </li>
  <li>
    <p>el operador punto puede ser sobrecargado, permitiendo así que tipos usen la sintáxis <code class="highlighter-rouge">obj.propiedad</code> para
comportamientos que no sea accesar o fijar campos de structs. Esto es especialmente útil para facilitar
la interoperabilidad con lenguajes basados en clases como Python y Java. Esto también permite sobrecargar la
sintáxis para obtener una columna de datos y que empate con la de tuplas nombradas: puedes escribir
<code class="highlighter-rouge">tabla.versión</code> para accesar la columna <code class="highlighter-rouge">versión</code> de una tabla ó <code class="highlighter-rouge">row.versión</code> accesa el campo
<code class="highlighter-rouge">versión</code> de una sóla hilera.</p>
  </li>
  <li>
    <p>El optimizador de Julia se ha vuelto mucho más listo en demasiadas maneras para aquí enlistarlas, pero
algunas de ellas valen mencionar. El optimizador ahora nos permite propagar constantes a través de llamadas
a funciones, permitiendo mucha mejor eliminación de código muerto y evaluación estática que antes. El compilador
ahora también es mucho mejor evitando alocaciónes de wrappers efímeros alrededor de objetos longevos, permitiendo
a los programadores a usar abstracciones de alto nivel sin costo de rendimiento.</p>
  </li>
  <li>
    <p>Los constructores de tipos paramétricos ahora se llaman con la misma sintáxis con la que se declaran. Esto
elimina una barrera rebuscada pero confusa de sintáxis.</p>
  </li>
  <li>
    <p>El protocolo de iteración ha sido completamente rediseñado para facilitar implementar muchos tipos de 
iterables. En vez de —<code class="highlighter-rouge">start</code>, <code class="highlighter-rouge">next</code>, <code class="highlighter-rouge">done</code>—uno ahora define métodos de uno y dos argumentos para la función
<code class="highlighter-rouge">iterate</code>. Esto frecuentemente permite que la iteración se defina con un sólo método y un valor por default para 
el estado inicial. Aúnado a lo anterior, es posible implementar iteradores que sólo saben si han terminado
una vez que han intentado y fallado en producir un valor – justo el tipo de iteradores que son ubicuos en I/O,
producidores/consumidores, etc. Julia puede expresar estos iteradores directa y correctamente.</p>
  </li>
  <li>
    <p>Las reglas de alcance han sido simplificadas. Construcciones que introducen alcances locales ahora lo hacen
de manera consistente, sin importar los enlaces globales para nombre preexistentes o no. Esto elimina la distinción de
alcances “duros/suaves” que previamente existía y significa que Julia siempre puede determinar estáticamente si variables son
locales o globales.</p>
  </li>
  <li>
    <p>El lenguaje en sí es significativamente más esbelto, con muchos componentes siendo escindidos a paquetes en la
“biblioteca estándar” que es liberada con Julia pero que no es parte del lenguaje “base”. Si los necesitas, sólo
necesitas importar (sin instalar) pero no estarás coaccionada a hacerlo. En el futuro, esto permitirá que las bibliotecas
estándar sean versionadas y actualizadas independientemente de Julia, permitiendo que evolucionen y se mejoren más rápido.</p>
  </li>
  <li>
    <p>Hemos revisado extensamente todas las APIs de Julia para mejorar la consistencia y usabilidad. Muchos nombres rebuscados
tradicionales y patrones ineficientes han sido renombrados o refactorizados para empatar elegantemente con las capacidades de Julia.
Esto ha promovido cambios para trabajar con colecciones de manera más consistente y coherente, y asegurar que el orden de los argumentos
sea un estándar consistente a lo largo del lenguaje, y para incorporar los (ahora más rápidos) argumentos “keyword” en las APIs
apropiadas.</p>
  </li>
  <li>
    <p>Un gran número de paquetería externa ha sido específicamente construida alrededor de las ventajas de Julia 1.0, tales como:</p>
    <ul>
      <li>
        <p>El ecosistema de procesamiento y manipulación de manejo de datos fue reorganizado alrededor de los valores faltantes.</p>
      </li>
      <li>
        <p><a href="https://github.com/jrevels/Cassette.jl">Cassette.jl</a> provee un poderoso mecanismo para inyectar pases de transformación de
  código al compilador de Julia, permitiendo análisis post-hoc y extensión de código existente. Además de la instrumentación para
  programadores como un debugger y un profiler, esto también puede implementar diferenciación automática para tareas de machine learning.</p>
      </li>
      <li>
        <p>Se ha incrementado enormemente el soporte para arquitecturas heterogéneas y se ha desacoplado aún más del funcionamiento
  interno del compilador. Intel KNLs funcionan en Julia. Los GPUs de Nvidia son programados usando <a href="https://github.com/JuliaGPU/CUDAnative.jl">CUDANative.jl</a>
  y un port para los TPUs de Google está siendo elaborado.</p>
      </li>
    </ul>
  </li>
</ul>

<p>Son sólo algunas mejoras. Para una lista completa de los cambios, lee el archivo <a href="https://docs.julialang.org/en/release-0.7/NEWS/">0.7 NEWS</a>. En el post 
original <a href="https://julialang.org/blog/2012/02/why-we-created-julia">“Why We Created Julia” blog
post</a> en 2012, escribimos</p>

<blockquote>
  <p>No está completo, pero es tiempo de liberar la versión 1.0 del lenguaje que creamos llamado
<a href="https://julialang.org">Julia</a>.</p>
</blockquote>

<p>Tal vez nos adelantamos un poco con la versión 1.0, pero el tiempo finalmente ha llegado y es un release fantástico. 
Estamos verdaderamente orgullosos de lo que hemos logrado con los miles de programadores que han contribuido en tantas maneras a este lenguaje
verdaderamente moderno para programación general y numérica.</p>


</div>



</div>
</div>
</div>

<br />


  </div>

  <footer class="container-fluid footer-copy">
  <div class="container">
    <div class="row">
      <div class="col-md-10 py-2">
        <p>
           ©2018 JuliaCN Julia 中文社区. All rights reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

  <script src="/v2/js/jquery.min.js"></script>
<script src="/v2/js/bootstrap.min.js"></script>
<script src="/v2/js/platform.js"></script>
<script src="/v2/js/app.js"></script>
<script src="/v2/js/highlight.pack.js"></script>
<script async defer src="https://buttons.github.io/buttons.js"></script>
</body>

</html>
